<!DOCTYPE html>
<html lang="si">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tuk Rush - Ultimate Night</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Sinhala:wght@400;700;900&family=Orbitron:wght@900&display=swap" rel="stylesheet">
    
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Noto Sans Sinhala', sans-serif; touch-action: none; user-select: none; }
        .font-tech { font-family: 'Orbitron', sans-serif; letter-spacing: 2px; }
        
        /* Mirror Styling */
        .mirror-frame {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            width: 160px; height: 70px;
            background: rgba(0, 0, 0, 0); 
            border: 3px solid #888; border-radius: 12px;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
            z-index: 50; overflow: hidden;
        }
        .mirror-glass {
            position: absolute; inset: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 50%);
            pointer-events: none;
        }
        
        /* Side Warning Notification (Top Right) */
        #warning-container {
            position: absolute; top: 90px; right: 0; 
            display: flex; flex-direction: column; align-items: flex-end; gap: 10px;
            pointer-events: none; overflow: hidden; padding-right: 10px;
        }
        .bus-alert {
            background: linear-gradient(90deg, #800080, #ff00ff);
            color: white; padding: 10px 20px; border-radius: 8px 0 0 8px;
            font-weight: 900; text-transform: uppercase;
            border-left: 5px solid #ffff00;
            box-shadow: -5px 5px 15px rgba(0,0,0,0.5);
            transform: translateX(100%);
            animation: slideIn 0.3s forwards, pulseWarn 0.5s infinite alternate;
        }
        @keyframes slideIn { to { transform: translateX(0); } }
        @keyframes pulseWarn { from { text-shadow: 0 0 5px white; } to { text-shadow: 0 0 20px yellow; } }

        .danger-overlay { animation: flashRed 0.5s infinite; pointer-events: none; }
        @keyframes flashRed { 0%, 100% { box-shadow: inset 0 0 0 red; } 50% { box-shadow: inset 0 0 80px red; } }
        
        .rules-list li { margin-bottom: 6px; font-size: 0.85rem; color: #ddd; text-align: left; display: flex; align-items: start; gap: 6px; }
        .rules-list span { color: #FACC15; font-weight: bold; white-space: nowrap; }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div id="game-container" class="absolute inset-0 z-0"></div>

    <div id="game-ui" class="absolute inset-0 z-10 hidden flex-col justify-between p-4 pointer-events-none">
        
        <div class="flex justify-between items-start w-full pointer-events-auto mt-1 relative">
            <div class="bg-gray-800/80 backdrop-blur border-l-4 border-yellow-500 px-4 py-2 rounded-r-xl shadow-lg">
                <p class="text-[10px] text-gray-400 font-bold uppercase">SCORE</p>
                <p id="score-display" class="text-2xl font-black font-tech text-yellow-400">0</p>
            </div>

            <div class="mirror-frame" id="mirror-box">
                <div class="mirror-glass"></div>
                <div id="mirror-alert" class="absolute inset-0 border-4 border-red-600 hidden animate-pulse"></div>
            </div>

            <div class="bg-gray-800/80 backdrop-blur border-r-4 border-blue-500 px-4 py-2 rounded-l-xl shadow-lg">
                <p class="text-[10px] text-gray-400 font-bold uppercase text-right">PICKUPS</p>
                <p id="passenger-count" class="text-2xl font-black text-right font-tech text-blue-400">0</p>
            </div>
        </div>

        <div id="warning-container"></div>
    </div>

    <div id="start-screen" class="absolute inset-0 z-20 flex flex-col items-center justify-center bg-black/95 p-4 text-center overflow-y-auto">
        <h1 class="text-5xl font-black text-yellow-400 mb-2 italic tracking-tighter font-tech" style="text-shadow: 0 0 25px orange;">
            TUK<br><span class="text-white">RUSH</span>
        </h1>
        
        <div class="bg-gray-800 p-5 rounded-xl border border-gray-700 max-w-sm w-full mb-6 shadow-2xl text-left">
            <h3 class="text-white font-bold text-lg mb-3 border-b border-gray-600 pb-2">üö¶ ‡∂ú‡∑ö‡∂∏‡∑ä ‡∂ë‡∂ö‡∑ö ‡∂±‡∑ì‡∂≠‡∑í:</h3>
            <ul class="rules-list pl-1">
                <li><span>üëÄ ‡∂ö‡∂±‡∑ä‡∂±‡∑è‡∂©‡∑í‡∂∫:</span> ‡∂¥‡∑É‡∑ä‡∑É‡∑ô‡∂±‡∑ä ‡∂ë‡∂± "‡∑Ñ‡∑ô‡∂Ω‡∂ú‡∑ù" ‡∂ß‡∑î‡∂ö‡∑ä ‡∂ë‡∂ö ‡∂∂‡∂Ω‡∂±‡∑ä‡∂±.</li>
                <li><span>üôã‚Äç‚ôÇÔ∏è ‡∂∏‡∂ú‡∑ì‡∂±‡∑ä:</span> ‡∂∏‡∂ú‡∑ì‡∂±‡∑ä‡∑Ä ‡∂ú‡∂≠‡∑ä‡∂≠‡∂∏ Boost ‡∑Ä‡∑ô‡∂±‡∑Ä‡∑è.</li>
                <li><span>üöå ‡∂¥‡∑í‡∑É‡∑ä‡∑É‡∑î ‡∂∂‡∑É‡∑ä:</span> ‡∂Ω‡∂ö‡∑î‡∂´‡∑î 150 ‡∂¥‡∑ê‡∂±‡∑ä‡∂±‡∂∏ "‡∂∏‡∑è‡∂ª ‡∑É‡∑ô‡∂±‡∂ú", "‡∂ö‡∑ê‡∂Ω‡∑ö ‡∂ª‡∂¢‡∑è" ‡∑Ä‡∂ú‡∑ö ‡∂¥‡∑í‡∑É‡∑ä‡∑É‡∑î ‡∂∂‡∑É‡∑ä ‡∂ë‡∂±‡∑Ä‡∑è. ‡∂Ö‡∂∫‡∑í‡∂±‡∑ä ‡∑Ä‡∑ô‡∂±‡∑ä‡∂±!</li>
            </ul>
        </div>
        
        <div class="w-full max-w-xs space-y-3">
            <input type="text" id="player-name" placeholder="‡∂î‡∂∫‡∑è‡∂ú‡∑ö ‡∂±‡∂∏" maxlength="12"
                   class="w-full px-4 py-3 rounded-xl bg-gray-900 border-2 border-gray-600 text-white text-center font-bold outline-none focus:border-yellow-500 transition-colors">
            
            <button onclick="startGame()" class="w-full bg-yellow-500 hover:bg-yellow-400 text-black font-black text-xl py-4 rounded-xl shadow-lg transform active:scale-95 transition font-tech">
                START RACE ‚ñ∂
            </button>
        </div>
    </div>

    <div id="game-over-screen" class="hidden absolute inset-0 z-30 flex flex-col items-center justify-center bg-black/95 backdrop-blur-md p-6 text-center">
        <h2 class="text-6xl font-black text-red-600 mb-2 italic font-tech">WASTED!</h2>
        <div class="bg-gray-900 p-6 rounded-2xl w-full max-w-sm border border-gray-800 shadow-2xl mb-6">
            <p class="text-xs text-gray-500 uppercase mb-1">Your Rank</p>
            <h3 id="funny-badge" class="text-2xl font-black text-yellow-400 mb-4 animate-pulse">???</h3>
            <div class="flex justify-between text-sm text-gray-400 border-t border-gray-800 pt-4">
                <span>Total Score:</span>
                <span id="final-score" class="font-bold text-white text-xl">0</span>
            </div>
        </div>
        <div class="flex flex-col gap-3 w-full max-w-sm">
            <button onclick="shareScore()" class="bg-green-600 hover:bg-green-500 text-white font-bold py-4 rounded-xl shadow-lg transform hover:scale-105 transition flex items-center justify-center gap-2">
                <span>üì≤</span> ‡∂∫‡∑è‡∂Ω‡∑î‡∑Ä‡∂±‡∑ä‡∂ß‡∂≠‡∑ä ‡∂ö‡∑í‡∂∫‡∂∏‡∑î ‡∂∏‡∂†‡∑ù
            </button>
            <button onclick="window.location.reload()" class="bg-white hover:bg-gray-200 text-black font-bold py-4 rounded-xl shadow-lg transition flex items-center justify-center gap-2">
                <span>üîÑ</span> ‡∂Ü‡∂¥‡∑Ñ‡∑î ‡∂∫‡∂∏‡∑î (Try Again)
            </button>
        </div>
    </div>

    <div id="danger-overlay" class="absolute inset-0 pointer-events-none hidden danger-overlay"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const CONFIG = { laneWidth: 14, startSpeed: 0.6, maxGap: 30, enemySpeed: 0.02 };
        
        // FUNNY BUS NAMES LIST
        const BUS_NAMES = [
            "‡∂∏‡∑è‡∂ª ‡∑É‡∑ô‡∂±‡∂ú", "‡∂ö‡∑ê‡∂Ω‡∑ö ‡∂ª‡∂¢‡∑è", "‡∑Ñ‡∑ù‡∂Ω‡∑ä‡∂ß‡∑ä ‡∂±‡∑ë", "‡∂ö‡∑î‡∂©‡∑î ‡∂ë‡∂ö‡∑ä‡∑É‡∑ä‡∂¥‡∑ä‚Äç‡∂ª‡∑É‡∑ä", 
            "‡∂±‡∂∫‡∑í‡∂ß‡∑ä ‡∂ª‡∂∫‡∑í‡∂©‡∂ª‡∑ä", "‡∂Ö‡∑Ä‡∂≠‡∑è‡∂ª‡∑ö", "‡∑É‡∑ú‡∂±‡∑í‡∂ö‡∑ä", "Road Killer", 
            "‡∂∏‡∑è‡∂ª ‡∂Ø‡∑ñ‡∂≠‡∂∫‡∑è", "Jet Liner", "Air Bus", "Flying Fish"
        ];

        let state = {
            isPlaying: false, score: 0, passengers: 0, gap: 20, 
            speedMultiplier: 1.0, frame: 0, playerName: "Rider", entities: []
        };
        let animationId;

        // Three.js Setup
        const scene = new THREE.Scene(); scene.background = new THREE.Color(0x050505); scene.fog = new THREE.Fog(0x050505, 10, 100);
        const mainCamera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        mainCamera.position.set(0, 6, 14); mainCamera.lookAt(0, 0, -10);
        const mirrorCamera = new THREE.PerspectiveCamera(60, 2.2, 0.1, 1000);
        mirrorCamera.position.set(0, 4, -4); mirrorCamera.lookAt(0, 2, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true; renderer.autoClear = false;
        document.getElementById('game-container').appendChild(renderer.domElement);

        const ambLight = new THREE.AmbientLight(0xffffff, 0.2); scene.add(ambLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5); dirLight.position.set(10, 20, 10); dirLight.castShadow = true; scene.add(dirLight);
        const headLight = new THREE.SpotLight(0xffffaa, 1.8); headLight.position.set(0, 3, -1); headLight.target.position.set(0, 0, -30);
        headLight.angle = 0.6; headLight.penumbra = 0.5; headLight.castShadow = true; scene.add(headLight); scene.add(headLight.target);

        // Helper: Create Box
        function createBox(w, h, d, color, x, y, z, parent) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat); mesh.position.set(x, y, z); mesh.castShadow = true;
            if(parent) parent.add(mesh); return mesh;
        }

        // Helper: Text Texture for Bus Names
        function createNameTexture(name) {
            const cvs = document.createElement('canvas'); cvs.width = 256; cvs.height = 64;
            const ctx = cvs.getContext('2d');
            // Transparent background
            ctx.fillStyle = "rgba(0,0,0,0)"; ctx.fillRect(0,0,256,64);
            // Text Style
            ctx.shadowColor = "black"; ctx.shadowBlur = 4;
            ctx.fillStyle = "#FFD700"; // Gold color
            ctx.font = "bold 30px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(name, 128, 32);
            return new THREE.CanvasTexture(cvs);
        }

        // --- Create Private Bus with Name ---
        function createPrivateBus() {
            const group = new THREE.Group();
            const colors = [0x8A2BE2, 0x0000FF, 0xFF1493, 0x00FF00];
            const col = colors[Math.floor(Math.random() * colors.length)];
            
            // Bus Body
            createBox(3.4, 3.8, 10, col, 0, 1.9, 0, group);
            const win = new THREE.Mesh(new THREE.BoxGeometry(3.5, 1.5, 8), new THREE.MeshStandardMaterial({color:0x000000}));
            win.position.set(0, 2.5, 0); group.add(win);

            // Blinking Lights
            const lights = [];
            const lGeo = new THREE.BoxGeometry(0.4, 0.4, 0.1);
            const lMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            [-1.2, 0, 1.2].forEach(x => {
                const l1 = new THREE.Mesh(lGeo, lMat.clone()); l1.position.set(x, 3.5, 5.1); group.add(l1); lights.push(l1);
                const l2 = new THREE.Mesh(lGeo, lMat.clone()); l2.position.set(x, 0.8, 5.1); group.add(l2); lights.push(l2);
            });

            // --- ADD NAME BOARD ---
            const randName = BUS_NAMES[Math.floor(Math.random() * BUS_NAMES.length)];
            const nameTex = createNameTexture(randName);
            const nameMat = new THREE.MeshBasicMaterial({ map: nameTex, transparent: true });
            const nameMesh = new THREE.Mesh(new THREE.PlaneGeometry(4, 1), nameMat);
            nameMesh.position.set(0, 4.2, 0); // Float above bus
            // Billboard effect (face camera? No, just face forward)
            // It will face +Z (towards player) by default if plane is created facing Z
            // Actually PlaneGeometry faces +Z. We want it to face +Z (towards camera).
            // But we might need to rotate it if it looks backwards. Let's test.
            // Actually objects move towards +Z. Camera looks at -Z.
            // Bus front is facing +Z. So text should face +Z.
            group.add(nameMesh);
            
            group.userData = { type: 'bus', lights: lights, busName: randName };
            return group;
        }

        // --- Tuks ---
        function createTuk(color, isHelago) {
            const group = new THREE.Group();
            createBox(1.5, 0.6, 2.8, color, 0, 0.6, 0, group); 
            createBox(1.4, 1.4, 1.4, color, 0, 1.4, 0.6, group); 
            createBox(1.3, 1.0, 0.6, color, 0, 1.0, -0.9, group); 
            const roof = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.1, 3.4), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            roof.position.set(0, 2.4, 0.1); group.add(roof);

            if(isHelago) {
                const cvs = document.createElement('canvas'); cvs.width=128; cvs.height=64;
                const ctx = cvs.getContext('2d'); ctx.fillStyle='#00A651'; ctx.fillRect(0,0,128,64);
                ctx.fillStyle='white'; ctx.font='bold 24px Arial'; ctx.fillText('HELAGO', 15, 40);
                const tex = new THREE.CanvasTexture(cvs);
                const sign = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.5, 0.1), new THREE.MeshBasicMaterial({map:tex}));
                sign.position.set(0, 2.8, 0); group.add(sign);
                const glow = new THREE.PointLight(0x00ff00, 1, 10); glow.position.set(0, 2, 0); group.add(glow);
            } else {
                createBox(0.4, 0.2, 0.1, 0xffffaa, 0, 0.8, -1.2, group);
            }
            return group;
        }

        const playerTuk = createTuk(0xDC2626, false); scene.add(playerTuk);
        const enemyTuk = createTuk(0x00A651, true); scene.add(enemyTuk);

        // Road
        const road = new THREE.Mesh(new THREE.PlaneGeometry(30, 2000), new THREE.MeshStandardMaterial({ color: 0x222222 }));
        road.rotation.x = -Math.PI/2; road.position.z = -500; road.receiveShadow = true; scene.add(road);
        const lines = [];
        for(let i=0; i<40; i++) {
            const l = new THREE.Mesh(new THREE.PlaneGeometry(0.3, 10), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            l.rotation.x = -Math.PI/2; l.position.set(0, 0.05, -i*25); scene.add(l); lines.push(l);
        }

        let targetX = 0;

        // --- Logic ---
        window.startGame = function() {
            state.playerName = document.getElementById('player-name').value || "Rider";
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-ui').classList.remove('hidden');
            document.getElementById('game-ui').style.display = 'flex';
            state.isPlaying = true; animate();
        };

        // --- Side Warning Function ---
        function showSideWarning(text) {
            const container = document.getElementById('warning-container');
            const alert = document.createElement('div');
            alert.className = 'bus-alert';
            alert.innerHTML = `‚ö†Ô∏è ${text}`;
            container.appendChild(alert);
            
            // Remove after 2 seconds
            setTimeout(() => {
                alert.style.opacity = '0';
                setTimeout(() => alert.remove(), 300);
            }, 2000);
        }

        function spawnEntity() {
            const busChance = state.score > 150 ? 0.85 : 1.1; 
            const rand = Math.random();
            const x = (Math.random() - 0.5) * CONFIG.laneWidth;
            const z = -120 - Math.random() * 20;
            let mesh, isPassenger=false, isBus=false;

            if (rand < 0.3) {
                isPassenger = true;
                const g = new THREE.Group();
                const b = new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,1.2), new THREE.MeshStandardMaterial({color:0x3B82F6})); b.position.y=0.6;
                const h = new THREE.Mesh(new THREE.SphereGeometry(0.25), new THREE.MeshStandardMaterial({color:0xffccaa})); h.position.y=1.3;
                g.add(b); g.add(h); mesh = g;
            } else if (rand > busChance) {
                isBus = true;
                mesh = createPrivateBus();
                // Trigger SIDE Warning with the Bus Name
                showSideWarning(mesh.userData.busName);
            } else {
                mesh = new THREE.Mesh(new THREE.DodecahedronGeometry(1.0), new THREE.MeshStandardMaterial({color:0x555555})); 
                mesh.position.y=1.0;
            }
            mesh.position.set(x, mesh.position.y||0, z); 
            mesh.castShadow = true; scene.add(mesh);
            state.entities.push({ mesh, isPassenger, isBus });
        }

        function getBadge(score) {
            if (score < 500) return "‡∂±‡∑í‡∂ö‡∂∏‡∑ä‡∂∏ ‡∂á‡∂´‡∂∫‡∂ö‡∑ä üî©";
            if (score < 1500) return "‡∂¥‡∑è‡∂ª‡∑ä‡∂ö‡∑ä ‡∂ë‡∂ö‡∑ö ‡∂†‡∂´‡∑ä‡∂©‡∑í‡∂∫‡∑è üòé";
            if (score < 3000) return "‡∂¥‡∑í‡∑É‡∑ä‡∑É‡∑î ‡∂©‡∑ä‚Äç‡∂ª‡∂∫‡∑í‡∑Ä‡∂ª‡∑ä ü§™";
            return "‡∂∏‡∑Ñ ‡∑Ä‡∑í‡∂ö‡∑è‡∂ª‡∂∫‡∂ö‡∑ä üëëüî•";
        }

        window.shareScore = function() {
            const text = `‡∂Ö‡∂©‡∑ù ‡∂∏‡∂∏ ${state.playerName}! Helago ‡∂ë‡∂ö‡∑ô‡∂±‡∑ä ‡∂∂‡∑ö‡∂ª‡∑í‡∂Ω‡∑è "${getBadge(Math.floor(state.score))}" ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂ú‡∂≠‡∑ä‡∂≠‡∑è! ‡∑É‡∑ä‡∂ö‡∑ù‡∂ª‡∑ä ‡∂ë‡∂ö: ${Math.floor(state.score)}. ‡∑Ä‡∂ª‡∑ô‡∂±‡∑ä ‡∂ú‡∑ö‡∂∏‡∂ö‡∑ä ‡∂ú‡∑Ñ‡∂±‡∑ä‡∂±! üëá`;
            const url = window.location.href;
            if (navigator.share) navigator.share({ title: 'Tuk Rush', text: text, url: url });
            else { 
                const d = document.createElement("textarea"); d.value=text+" "+url; document.body.appendChild(d); d.select(); document.execCommand("copy"); document.body.removeChild(d);
                alert("Link Copied!"); 
            }
        };

        function gameOver() {
            state.isPlaying = false; cancelAnimationFrame(animationId);
            document.getElementById('game-ui').classList.add('hidden');
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('game-over-screen').style.display = 'flex';
            document.getElementById('final-score').innerText = Math.floor(state.score);
            document.getElementById('funny-badge').innerText = getBadge(state.score);
        }

        function animate() {
            if (!state.isPlaying) return;
            animationId = requestAnimationFrame(animate); state.frame++;
            renderer.clear();

            state.speedMultiplier = 1 + (state.score / 2000);
            const currentSpeed = CONFIG.startSpeed * state.speedMultiplier;

            playerTuk.position.x += (targetX - playerTuk.position.x) * 0.15;
            playerTuk.rotation.z = (playerTuk.position.x - targetX) * 0.08; 
            playerTuk.rotation.y = -(playerTuk.position.x - targetX) * 0.05; 
            headLight.position.x = playerTuk.position.x;
            headLight.target.position.x = playerTuk.position.x * 3;

            enemyTuk.position.z = state.gap; 
            enemyTuk.position.x += (playerTuk.position.x - enemyTuk.position.x) * 0.05;

            const spawnRate = Math.max(20, 60 - Math.floor(state.score/150));
            if(state.frame % spawnRate === 0) spawnEntity();

            for (let i = state.entities.length - 1; i >= 0; i--) {
                const ent = state.entities[i];
                let speed = currentSpeed; if(ent.isBus) speed *= 1.5; 
                ent.mesh.position.z += speed;

                if(ent.isBus && state.frame % 4 === 0) {
                    const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00];
                    ent.mesh.userData.lights.forEach(l => l.material.color.setHex(colors[Math.floor(Math.random()*colors.length)]));
                }

                const dx = Math.abs(ent.mesh.position.x - playerTuk.position.x);
                const dz = Math.abs(ent.mesh.position.z - playerTuk.position.z);

                if (dz < 2.5 && dx < 2.2) {
                    if (ent.isPassenger) {
                        state.score += 100; state.passengers++; state.gap += 5; if(state.gap>CONFIG.maxGap) state.gap=CONFIG.maxGap;
                        scene.remove(ent.mesh); state.entities.splice(i, 1);
                    } else {
                        if(ent.isBus) state.gap = -10; else { state.gap -= 8; state.score -= 50; }
                        scene.remove(ent.mesh); state.entities.splice(i, 1);
                        mainCamera.position.x = (Math.random()-0.5)*1; setTimeout(()=>mainCamera.position.x=0, 100);
                    }
                } else if (ent.mesh.position.z > 30) { scene.remove(ent.mesh); state.entities.splice(i, 1); }
            }

            lines.forEach(l => { l.position.z += currentSpeed; if(l.position.z > 20) l.position.z -= 1000; });
            state.gap -= CONFIG.enemySpeed * state.speedMultiplier; state.score += 0.5;

            document.getElementById('score-display').innerText = Math.floor(state.score);
            document.getElementById('passenger-count').innerText = state.passengers;
            if(state.gap < 8) document.getElementById('mirror-alert').classList.remove('hidden');
            else document.getElementById('mirror-alert').classList.add('hidden');
            if(state.gap <= 2) gameOver();

            renderer.setScissorTest(false);
            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
            renderer.render(scene, mainCamera);

            const mirrorBox = document.getElementById('mirror-box');
            if (mirrorBox) {
                const rect = mirrorBox.getBoundingClientRect();
                const w = rect.width; const h = rect.height; const l = rect.left; const b = window.innerHeight - rect.bottom; 
                renderer.setScissorTest(true); renderer.setScissor(l, b, w, h); renderer.setViewport(l, b, w, h);
                mirrorCamera.position.x = playerTuk.position.x;
                mirrorCamera.lookAt(enemyTuk.position.x, 2, enemyTuk.position.z);
                renderer.render(scene, mirrorCamera);
            }
        }
        
        window.addEventListener('touchmove', (e)=>{ if(state.isPlaying) targetX=(e.touches[0].clientX/window.innerWidth*CONFIG.laneWidth)-(CONFIG.laneWidth/2); }, {passive:false});
        window.addEventListener('mousemove', (e)=>{ if(state.isPlaying) targetX=(e.clientX/window.innerWidth*CONFIG.laneWidth)-(CONFIG.laneWidth/2); });
        window.addEventListener('resize', ()=>{ mainCamera.aspect=window.innerWidth/window.innerHeight; mainCamera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>
